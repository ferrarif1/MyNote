
佩德森的承诺
CT（ Confidential Transactions，机密交易）的基础密码学工具是佩德森的承诺。

承诺场景让你把一段数据作为私密保存，但是要承诺它，使得你后来不能改变该数据。一个简单的承诺场景用哈希函数构建如下：

承诺 = SHA256（盲化因子||数据）
如果你仅告诉别人承诺，别人没法确定你承诺了什么数据（对哈希表的属性给定某些假设）。但你后来揭露了盲化因子和数据，别人可以运行该哈希函数来验证是否与你以前的承诺相匹配。盲化因子必须存在，否则别人可以试图猜测数据。如果你的数据比较少而简单，猜测成功可能性比较大。

佩德森承诺与以上场景中的承诺类似，但是附加一个特性：承诺可以相加，多个承诺的总和等于数据总和的承诺（盲化因子的集合即盲化因子总和）：

C(BF1, data1) + C(BF2, data2) == C(BF1 + BF2, data1 + data2)
C(BF1, data1) - C(BF1, data1) == 0
换句话说，加法律和交换律适用于承诺。

If data_n = {1,1,2} and BF_n = {5,10,15} then: C(BF1, data1) + C(BF2, data2) - C(BF3, data3) == 0
我们用椭圆曲线点来构建具体的佩德森承诺（读者无需理解椭圆曲线密码学体系，当成黑盒行为来了解就可以了）。
通常，ECC公钥由私钥x乘以基点G生成。

PUB = xG
结果通常保存为33字节的数组。
ECC公钥遵守以前描述过的加法同态性：

PUB1 + PUB2 = (x1 + x2 ( mod n ))G
(以上特性被BIP32分层确定性钱包用来允许第三方生成新的比特币地址)

佩德森承诺的额外基点（我们叫H点）生成办法，因而没人知道H对G的离散对数（反之亦然），意思是说没人知道x，且xG = H。我们使用G哈希来选择H：

H = to_point(SHA256(ENCODE(G)))
这里to_point把输入当成椭圆曲线上某个点的x值，并且计算出y值。
给定两个基点我们能构建如下承诺场景：

承诺 = xG +ａH
这里ｘ是私密盲化因子，ａ是我们要承诺的金额，你可以用加法交换律验证加法同态承诺场景中的相关关系。
佩德森承诺是信息理论上的隐私，你看到的所有承诺，总能找到一些盲化因子，可以和任意金额一起匹配该承诺。如果你的盲化因子真的随机的话，甚至连具有无穷计算力的攻击者都不能分辨你承诺的金额。这些承诺对于假冒承诺来说是计算安全的，你实际上不能计算出任意映射。如果你做到，这就意味着你能找到两个基点相对于彼此的离散对数，意味着承诺群的安全性受到损害。

2 佩德森承诺应用
利用该工具，我们替换比特币交易中的８字节整数金额为32字节佩德森承诺.

如果一个交易的发起人认真选择他们的盲化因子,以便正确相加,然后网络还能通过承诺相加为0来验证该交易。

(In1 + In2 + In3 + plaintext_input_amountH...) -
(Out1 + Out2 + Out3 + ... feesH) == 0
以上公式需要明确的交易费用，在实际交易中，这点没有问题。
生成承诺和承诺验证非常简单，不幸的是，如果没有附加的措施这个场景是不安全的。

问题在于该群是循环群，加法要 mod P（一个256位的质数，用于定义群的秩），结果大数的加法会“溢出”，从而像个负数金额，因而当有些输出金额为负时，承诺加起来为0的特点依然存在，导致可凭空创造5个比特币。

(1 + 1) - (-5 + 7) == 0
以上式子可以被解释成“有人花了2个比特币，得到-5个比特币和7个比特币”。
为了防止产生这种情况，交易中有多输出的时候，我们必须证明每个承诺输出金额都在允许范围（如[0，2^64]）内且没有溢出。

我们可以公开金额和盲化因子，以便网络能检查，但是这样一来就损失了所有隐私。因而，我们要证明承诺的金额在允许范围内，除此之外不透露任何信息：我们需要额外密码学系统来证明佩德森承诺的范围，我们使用类似于Schoenmakers二元分解的技术，但是进行了许多优化（包括不使用二元）。

我们从基本的EC签名开始，如果生成了一个签名，签名的“消息”是公钥的哈希，该签名证明签名者知道私钥，即公钥对于某些基点的离散对数。

对于一个类似“公钥”的P = xG + aH ，因为基点H的存在，没有人知道P对于基点G的离散对数，因为没人知道x 使得xG = H，除非a为0。如果a为0，则P = xG ，离散对数恰好是x，有人会为该公钥签名。

把承诺当成公钥，对承诺的哈希值签名，通过这种方法，某个佩德森承诺可以被证明是对0值的承诺。在签名中使用公钥用于防止把签名设置成任意值并且破解出承诺。签名使用的私钥正是盲化因子。

更进一步，假定我想证明C是对金额1的承诺，但不告诉你盲化因子，你能做的就是计算：

C' = C - 1H
然后向我要公钥C'的签名（相对于基点G的签名），如果我能做到，则C一定是对金额1的承诺（否则我就破解了EC离散对数的安全性）。
